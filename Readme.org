* electric-case.el

camelCase、snake_caseの識別子をShiftキーなしで入力

insert camelCase and snake_case words, without "Shift"ing

** Screencast

[[screencast.gif]]

** Installation

Require this script

: (require 'electric-case)

and add initialize function to the major-mode hook.

: (eval-after-load "cc-mode"
:   '(add-hook 'java-mode-hook 'electric-case-java-init))

Now you may type identifiers in lisp-like way,

: class class-name
: {
:
: }

and electric-case will fix it.

: class ClassName
: {
:
: }

Settings for java, c, AHK, Scala are available by default.

: electric-case-c-init
: electric-case-java-init
: electric-case-ahk-init
: electric-case-scala-init

** Configuration

*** electric-case-convert-calls

electric-case only fixes declarations, by default. To enable
electric-case for all occurrences of identifiers, set
"electric-case-convert-calls" non-nil.

: (setq electric-case-convert-calls t)

This sometimes produces confusing results, and so is disabled by
default. For example,

: foo-bar

this is always fixed to

: fooBar

even when he meant subtraction.

*** electric-case-convert-xxxx

Regardless of "electric-case-convert-calls", hypens around numbers,
and hyphens at beginning/end of identifiers are not fixed. That is,

: -foo;
: foo-3-bar-4;
: qux--;

they are not fixed to

: Foo;
: foo3Bar4;
: qux;

You may change this behavior by setting following variables non-nil.

: electric-case-convert-beginning
: electric-case-convert-nums
: electric-case-convert-end

*** electric-case-pending-overlay

Identifiers that can be fixed are printed in gray. If this is not
comfortable for you, set "electric-case-pending-overlay" nil.

: (setq electric-case-pending-overlay)

You may also choose another face for the overlay.

: (setq electric-case-pending-overlay 'highlight)

** Work with Other Languages

Initializing functions (electric-case-xxx-init) actually do set two
variables, and turn electric-case-mode on. If you want to use
electric-case in other languages, you should configure these two
variables in major-mode hooks.

*** electric-case-criteria

Set a function that defines which case to convert the identifier
into. The function will be given two arguments: the beginning/end
position of the identifier, that is going to be converted. The
function must return one of camel (camelCase), ucamel (UpCamelCase),
snake (snake_case), usnake (UP_SNAKE_CASE) or nil. When the return
value is nil, fix for the identifier is canceled.

Remember that if "electric-case-convert-calls" is nil, identifiers not
in declarations are not expected to be converted. electric-case does
not judge if the identifier is in a declaration. So criteria function
should return in that case.

Here is an example for C-language.

: (setq electric-case-criteria
:       (lambda (b e n)
:         (let ((proper (text-properties-at b)))
:           (cond ((member 'font-lock-function-name-face proper) 'snake)
:                 ((member 'font-lock-variable-name-face proper)
:                  (if (member '(cpp-macro) (c-guess-basic-syntax))
:                      'usnake 'snake))
:                 (electric-case-convert-calls 'snake)
:                 (t nil)))))

With criteria above, function declarations and variable declarations
are converted into snake_case. Macro declarations are converted into
UP_SNAKE_CASE.

*** electric-case-max-iteration

For example, in Java, the syntactical category of the symbol
"what-is-this" below is not decidable currently.

: class MyClass{
:     what-is-this
: }

But when "symbol;" is added, now "what-is-this" is a name of a class.

: class MyClass{
:     what-is-this symbol;
: }

So electric-case can fix it into UpCamelCase.

: class MyClass{
:     WhatIsThis symbol;
: }

In the example above, the symbol "what-is-this" should be checked
twice or more. Otherwise, "what-is-this" is not fixed. Then
"electric-case-max-iteration" should be 2 or greater.

** Known Bugs and Limitations

- In java, class names that end with "Class" are not fixed correctly
